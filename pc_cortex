#!/usr/bin/env python3
"""
PC Cortex - Standalone Memory Bank Builder
Can be installed globally to analyze any codebase
"""

import argparse
import json
import logging
import sys
import os
from datetime import datetime
from pathlib import Path
import asyncio
import subprocess
import shutil

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Get the directory where this script is located
SCRIPT_DIR = Path(__file__).parent.resolve()

# System prompt for memory bank generation
SYSTEM_PROMPT = """You are an expert Memory Bank Builder specialized in analyzing codebases and creating comprehensive memory banks following a specific structure. Your task is to analyze a software repository and generate a complete memory bank that captures the project's essence, architecture, and current state.

## Core Competencies
- Deep code analysis and pattern recognition
- Architecture understanding and documentation
- Progress tracking and task management
- Technical decision extraction
- Dependency and relationship mapping

## Memory Bank Structure to Generate

### 1. projectbrief.md
Extract and document:
- Core project purpose and requirements
- Main goals and objectives
- Key features and functionality
- Success criteria

### 2. productContext.md
Analyze and document:
- Problem the project solves
- Target users and use cases
- User experience goals
- Business value and impact

### 3. systemPatterns.md
Identify and document:
- System architecture (monolithic, microservices, etc.)
- Design patterns used (MVC, Repository, Factory, etc.)
- Component relationships and interactions
- Data flow patterns
- Key architectural decisions

### 4. techContext.md
Catalog and document:
- Programming languages and versions
- Frameworks and libraries
- Development tools and setup
- External dependencies
- Technical constraints and requirements

### 5. activeContext.md
Assess and document:
- Current development focus
- Recent changes and commits
- Active branches and features
- Open issues and PRs
- Next planned steps

### 6. progress.md
Evaluate and document:
- Implemented features
- Working functionality
- Pending features
- Known bugs and issues
- Test coverage status

### 7. tasks/ folder structure
Create task documentation for:
- Active development tasks
- Planned features
- Bug fixes needed
- Technical debt items

Focus on creating a memory bank that enables complete project understanding even after memory resets."""


class MemoryBankBuilder:
    """Standalone memory bank builder"""
    
    def __init__(self, repo_path: Path, output_path: Path):
        self.repo_path = repo_path.resolve()
        self.output_path = output_path.resolve()
        
    def validate_inputs(self) -> bool:
        """Validate repository path and create output directory"""
        if not self.repo_path.exists():
            logger.error(f"Path does not exist: {self.repo_path}")
            return False
            
        if not self.repo_path.is_dir():
            logger.error(f"Path is not a directory: {self.repo_path}")
            return False
            
        # Create output directory if it doesn't exist
        self.output_path.mkdir(parents=True, exist_ok=True)
        logger.info(f"Output directory ready: {self.output_path}")
        
        return True
    
    async def analyze_with_claude(self) -> bool:
        """Analyze codebase using Claude"""
        
        # Check if claude is available
        if not shutil.which("claude"):
            logger.error("Claude CLI not found. Please install it with: npm install -g @anthropic-ai/claude-code")
            return False
        
        # Create memory-bank subdirectory
        memory_bank_dir = self.output_path / "memory-bank"
        memory_bank_dir.mkdir(exist_ok=True)
        
        # Create tasks subdirectory
        tasks_dir = memory_bank_dir / "tasks"
        tasks_dir.mkdir(exist_ok=True)
        
        prompt = f"""{SYSTEM_PROMPT}

Analyze the codebase in the current directory and create a complete memory bank.

First, explore the codebase to understand the project structure, technologies, and current state.

Then, create comprehensive content for each of the following files:

### File: projectbrief.md
[Write comprehensive content here]

### File: productContext.md
[Write comprehensive content here]

### File: systemPatterns.md
[Write comprehensive content here]

### File: techContext.md
[Write comprehensive content here]

### File: activeContext.md
[Write comprehensive content here]

### File: progress.md
[Write comprehensive content here]

Use the exact format above with '### File:' headers."""
        
        cmd = [
            "claude",
            "-p", prompt,
            "--output-format", "json"
        ]
        
        logger.info("Invoking Claude to analyze codebase...")
        logger.info("This may take a few minutes...")
        
        try:
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=str(self.repo_path)
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                logger.error(f"Claude failed: {stderr.decode('utf-8')}")
                return False
                
            # Parse JSON response
            try:
                response_data = json.loads(stdout.decode('utf-8'))
                content = response_data.get('result', '')
                
                if not content:
                    logger.error("No content in Claude response")
                    return False
                
                # Parse memory bank files
                self.parse_and_save_memory_bank(content, memory_bank_dir)
                
                # Create tasks index
                index_path = tasks_dir / "_index.md"
                with open(index_path, 'w') as f:
                    f.write("# Tasks Index\n\n## In Progress\n\n## Pending\n\n## Completed\n\n## Abandoned\n")
                logger.info(f"Created: {index_path}")
                
                # Save graph structure
                self.save_graph_structure()
                
                # Save generation summary
                self.save_summary()
                
                return True
                
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse Claude response: {e}")
                return False
                
        except Exception as e:
            logger.error(f"Error invoking Claude: {e}")
            return False
    
    def parse_and_save_memory_bank(self, content: str, memory_bank_dir: Path):
        """Parse and save memory bank files from Claude's response"""
        
        # Split content by file markers
        lines = content.split('\n')
        current_file = None
        current_content = []
        files_saved = []
        
        for line in lines:
            # Check for file markers
            if line.startswith("### File:"):
                # Save previous file if exists
                if current_file and current_content:
                    file_path = memory_bank_dir / current_file
                    with open(file_path, 'w') as f:
                        f.write('\n'.join(current_content).strip())
                    logger.info(f"Created: {file_path}")
                    files_saved.append(current_file)
                
                # Extract filename
                current_file = line.split(":", 1)[1].strip()
                current_content = []
            elif current_file:
                current_content.append(line)
        
        # Save last file
        if current_file and current_content:
            file_path = memory_bank_dir / current_file
            with open(file_path, 'w') as f:
                f.write('\n'.join(current_content).strip())
            logger.info(f"Created: {file_path}")
            files_saved.append(current_file)
        
        # Create any missing files
        expected_files = [
            "projectbrief.md",
            "productContext.md", 
            "systemPatterns.md",
            "techContext.md",
            "activeContext.md",
            "progress.md"
        ]
        
        for filename in expected_files:
            if filename not in files_saved:
                file_path = memory_bank_dir / filename
                with open(file_path, 'w') as f:
                    f.write(f"# {filename}\n\n*Content to be generated*")
                logger.warning(f"Created placeholder: {file_path}")
    
    def save_graph_structure(self):
        """Save graph structure for MCP navigation"""
        graph_path = self.output_path / "graph.json"
        graph = {
            "nodes": [],
            "edges": [],
            "metadata": {
                "version": "1.0.0",
                "created_at": datetime.now().isoformat(),
                "source_path": str(self.repo_path),
                "generator": "pc_cortex"
            }
        }
        with open(graph_path, 'w') as f:
            json.dump(graph, f, indent=2)
        logger.info(f"Created: {graph_path}")
    
    def save_summary(self):
        """Save generation summary"""
        summary_path = self.output_path / "generation_summary.json"
        summary = {
            "generated_at": datetime.now().isoformat(),
            "source_path": str(self.repo_path),
            "output_path": str(self.output_path),
            "generator": "pc_cortex_standalone"
        }
        with open(summary_path, 'w') as f:
            json.dump(summary, f, indent=2)
        logger.info(f"Created: {summary_path}")
    
    async def build(self) -> bool:
        """Execute the memory bank building process"""
        logger.info(f"PC Cortex - Memory Bank Builder")
        logger.info(f"Analyzing: {self.repo_path}")
        logger.info(f"Output: {self.output_path}")
        
        # Validate inputs
        if not self.validate_inputs():
            return False
        
        # Run analysis
        success = await self.analyze_with_claude()
        
        if success:
            logger.info("✅ Memory bank building completed successfully!")
            logger.info(f"Output saved to: {self.output_path}")
        else:
            logger.error("❌ Memory bank building failed!")
            
        return success


async def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="PC Cortex - Generate memory banks for any codebase",
        epilog="Example: pc_cortex /path/to/project -o ./project_memory_bank"
    )
    parser.add_argument(
        "path",
        type=Path,
        nargs='?',
        default=Path.cwd(),
        help="Path to analyze (default: current directory)"
    )
    parser.add_argument(
        "-o", "--output",
        type=Path,
        default=None,
        help="Output directory (default: ./[folder_name]_memory_bank)"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose logging"
    )
    parser.add_argument(
        "--version",
        action="version",
        version="PC Cortex 1.0.0"
    )
    
    args = parser.parse_args()
    
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
    
    # Determine output path
    if args.output is None:
        folder_name = args.path.name if args.path.name else "current"
        # Place the output in the current working directory, not in the analyzed directory
        args.output = Path.cwd() / f"{folder_name}_memory_bank"
    
    # Create builder and run
    builder = MemoryBankBuilder(args.path, args.output)
    success = await builder.build()
    
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    asyncio.run(main())